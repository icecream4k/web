<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="../../public_static_files/logo/vue.png">
    <title>脚手架</title>
    <style>
        .header_d1 {
            text-align: center;
        }
    </style>
</head>

<body>
    <div class="header_d1">
        <h1><span style="color:#41b783 ;">Vue-Cli 脚手架</span>以及<span style="color: #bdcaab;">ES6</span>部分知识</h1>
    </div>
    <hr>
    <ul>
        <li>
            <h1>脚手架的安装和介绍</h1>
        </li>
        <li>
            <h3>
                什么是脚手架：已经具有核心功能的标准化的半成品项目
            </h3>
        </li>
        <li>
            <h3>为什么使用脚手架：</h3>
            <ul>
                <li>
                    标准化：凡是用vue脚手架工具生成的脚手架代码结构完全一样
                </li>
                <li>
                    半成品：因为脚手架已经包含了大量核心代码,开发人员无需重复配置项目,只要专注于自己个性化定制的部分内容即可！省事,效率高！
                </li>
            </ul>
        </li>
        <li>
            <h3>
                何时使用：今后所有企业中的前段项目都是在脚手架代码基础上开发的
            </h3>

        </li>
        <li>
            <h3>如何使用：2步</h3>

            <ul>
                <li>
                    先安装用于反复生成脚手架的命令行工具：(一只老母鸡)[不需要每个项目重复做]--在任意目录下都行<br>
                    npm i -g @vue/cli
                </li>
                <li>
                    再用脚手架命令行工具反复生成项目脚手架源代码(老母鸡下蛋)[每做一个新项目,都要重新做一遍]<br>
                    在想要创建项目的文件夹目录下运行：vue create 项目名<br>
                    结果：在这个文件夹目录下从无到有创建出一个具有核心功能的vue脚手架项目源代码<br>
                </li>
            </ul>
        </li>
        <li>
            <h3>vue create 项目名：安装步骤</h3>
            <ul>
                <li>
                    第一步,选择预设,推荐选择第二个的自定义
                </li>
                <li>
                    第二步,选择需要的内容,按空格选择<br>
                    ◉ Babel - 把es6,es7等新代码,翻译成es5的等效代码 必须要选<br>
                    ◯ TypeScript<br>
                    ◯ Progressive Web App (PWA) Support<br>
                    ◉ Router - 单页面应用的核心组件<br>
                    ◉ Vuex - 做项目必选<br>
                    ◯ CSS Pre-processors - 如果你的项目用了sass或者less才选这项<br>
                    ◯ Linter / Formatter - 代码格式检查工具,一定不要选,要求过于苛刻<br>
                    ◯ Unit Testing<br>
                    ◯ E2E Testing<br>
                </li>
                <li>
                    Use history mode for router?是否使用history格式作为路由格式 有服务端就选y,否则选n<br>
                    需要 提供服务器端支持 首页重定向 在生产环境中
                </li>
                <li>
                    Where do you prefer placing config for Babel, ESLint, etc.? <br>
                    你更喜欢把babel,eslint等的配置放在哪里 <br>
                    In dedicated config files <br>
                    放在各自独立的配置文件中<br>
                    In package.json <br>
                    所有配置统一放在一个package.json文件中<br>
                </li>
                <li>
                    Save this as a preset for future projects?<br>
                    是否保存本次配置为将来的预设 n 不保存<br>
                </li>
                <li>等待loding</li>
                <li>
                    看到 - 就算成功<br>
                    🎉 Successfully created project xzvue.<br>
                    👉 Get started with the following commands:<br>
                    结果：在当前目录下创建了一个指定名称的文件夹,其中包含vue项目脚手架核心代码<br>
                    如果自己开发项目或者做实验,可以删除.git文件夹<br>
                </li>
                <li>
                    首次运行半成品脚手架项目:
                    <ul>
                        <li>用VScode打开刚创建的新项目文件夹</li>
                        <li>右键点击package.json文件,在‘终端/命令行中打开’</li>
                        <li>在VScode弹出的对话框中,等待出现输入光标的提示后,再输入npm run serve</li>
                        <li>
                            结果,做了两件事
                            <ul>
                                <li>starting development server ... 启动了一个简易开发服务器</li>
                                <li>Compiled successfully 编译成功(把代码中浏览器中可能不认识的es6和es7代码转化成es5代码；压缩和打包代码,放入临时的开发服务器中,允许开发人员测试网页)</li>
                            </ul>
                        </li>
                        <li>
                            在vscode中打开npm run serve ,没修改一下代码,就 会自动重新编译运行。不用重复运行npm run serve
                        </li>
                    </ul>
                </li>
                <li>
                    浏览当前项目中的"网页":<br>
                    vs code 中,按住ctrl 点命令行中出现的链接地址 - http://localhost:8080/
                </li>
            </ul>
        </li>
    </ul>
    <hr>
    <h2>懒加载</h2>
    <ul>
        <li>
            问题：单页面应用首屏加载时,默认会讲所有页面组件的内容都下载到客户端,首屏加载非常慢
        </li>
        <li>
            解决：2种方式
            <ul>
                <li>
                    什么是：将每个页面的组件内容单独打包未一个文件,首屏加载时,仅加载首屏页面一个组件的文件。当用户正在看首屏时,在底层使用异步请求,悄悄下载其他页面组件的文件
                </li>
                <li>
                    优点：依然可减少向服务器发送请求的次数,依然可在客户端更换页面组件,提高加载效率
                </li>
                <li>
                    缺点：偷跑流量
                </li>
            </ul>
        </li>
    </ul>
    <h2>全局组件</h2>
    <ul>
        <li>
            在src文件夹/components文件夹下新建组件 .vue文件
        </li>
        <li>
            在组件.vue文件中编写组件的HTML内容,css内容,和js内容<br>
            问题：此时,这个组件只是一个普通的子组件,还不是全局组件
        </li>
        <li>
            让这个组件变成全局组件：在src文件夹/main.js 中 new Vue()之前
            <ul>
                <li>
                    引入全局组件.vue:import myHeader from './component/myHeader.vue'
                </li>
                <li>
                    将引入的组件对象变成全局组件:Vue.component('组件名',组件对象)<br>
                    比如:想把myHeader变成全局组件：Vue.component('my-header',MyHeader)
                </li>
            </ul>
        </li>
        <li>
            结果:在当前脚手架中任何位置都可以使用&lt;my-header&gt;标签引入全剧组件
        </li>
    </ul>
    <hr>

    <ul>
        <li>
            <h1>箭头函数</h1>
            ES6中的 箭头函数来定义函数<br>
            const func = (参数列表)=>{函数体}<br>
            const func = (n1,n2)=>{return n1+n2}<br>
            const func = n=>{n*n} # 如果参数列表里面只有一个参数的时候,括号是可以省略的<br>
            例如 函数中有多行代码的时<br>
            const test = () => {<br>console.log('hello world');<br>console.log('hello world');<br>}<br>
            例如函数代码块中只有一行代码时<br>
            const mul = (n1,n2) => n1 + n2;<br>
            console.log(mul(30,40));<br>
            <hr>
            <h3>箭头函数中的this</h3>
            <p>箭头函数中的this引用的是最近作用域的this</p>
            <p>问题 - 箭头函数中的this是如何查找的? : 向外层作用域中,一层层查找this直到有this的定义</p>
            <p>一旦是function包含的this,那么指向就肯定是window,如果是两个箭头函数嵌套的this,那么指向的肯定是外层的对象</p>


        </li>
        <li>
            <h1>Vue Cli</h1>
            <p>创建vue项目 - vue init webpack projectname</p>
            <p>vue程序执行流程</p>
            <ol>
                <li>
                    <p>
                        template
                    </p>
                </li>
                <li>
                    <p>
                        ast
                    </p>
                </li>
                <li>
                    <p>
                        rander
                    </p>
                </li>
                <li>
                    <p>
                        virtual dom
                    </p>
                </li>
                <li>
                    <p>
                        真实 DOM
                    </p>
                </li>
            </ol>
            <hr>
            <p>
                runtime-compiler()<br>
                template -> ast -> rander -> vdom -> ui<br>
                runtime-only(1,性能更高 2,下面的vue代码量更少)<br>
                rander -> vdom -> ui<br>
            </p>
            <ol>vue-cli 3和2版本的区别
                <li>
                    <p>
                        vue-cli 3 是基于 webpack 4 打造的,vue-cli 2还是 webpack 3
                    </p>
                </li>
                <li>
                    <p>
                        vue-cli 3 的设计原则是 '0配置' ,移除的配置文件根目录下的,build和config等目录
                    </p>
                </li>
                <li>
                    <p>
                        vue-cli 3 提供了 vue ui 命令,提供了可视化配置,更加人性化
                    </p>
                </li>
                <li>
                    <p>
                        移除了 static 文件夹,新增了 public 文件夹,并且index.html 移动到 public 中
                    </p>
                </li>
            </ol>


        </li>
        <li>
            <h1>Vue-Router</h1>
            <p>什么是前端渲染,什么是后端渲染</p>
            <ol>
                <li>
                    <p>后端渲染</p>
                    <p>jsp : java server page</p>
                    <p>早期的网站开发整个HTML页面是由服务器渲染的</p>
                    <p>服务器直接生产渲染好的对应的HTML页面,由控制器路由分配,返回给客户端显示</p>
                    <p>后端路由的缺点 - 整个页面的模块都是由后端人员来编写和维护;前端开发如果要开发页面,需要通过PHP或者java来编写页面</p>
                </li>
                <li>
                    <p>前后端分离</p>
                    <p>后端只负责提供数据,不负责任何阶段的内容</p>
                    <p>前端浏览器中显示的网页中的大部分内容,都是由前端写的js代码再浏览器中执行,最终渲染出来的网页</p>
                </li>
                <li>
                    <p>单页面富应用 SPA</p>
                    <p>SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</p>
                    <p>整个页面只有一个HTML页面</p>
                    <p>核心 - 改变URL,但是页面不进行整体的刷新</p>
                </li>
            </ol>
            <p>router-link的补充</p>
            <p>router-link 除了 to ,还有一些比较常用的其他属性</p>
            <p>tag - tag可以指定 router-link 之后渲染成什么组件,比如渲染成一个button或者一个li元素等等</p>
            <p>replace - replace不会留下history记录,所以在指定replace的情况下,后退键不能返回到上一个页面中</p>
            <p>不常用 >> active-class 当router-link对应的路由匹配成功时,会自动给当前元素设置一个router-link-active的class,可以设置active-class修改默认的名称</p>
            <hr>
            <h3>动态路由</h3>
            <ul>
                <p>在某些情况下,一个页面的path路径可能是不确定的,比如用户进入我们的页面的时候,希望是如下的路径</p>
                <li>
                    <p>/user/aaaa或者/user/bbbb</p>
                </li>
                <li>
                    <p>除了有前面的/user之外,后面还跟上了用户ID</p>
                </li>
                <li>
                    <p>这种path和Component的匹配关系,我们称之为动态路由(也是路由传递数据的一种方式)</p>
                </li>
            </ul>
            <hr>
            <h3>路由的懒加载</h3>
            <p>当打包构建应用时,javascript包会变得非常大,影响页面价子啊</p>
            <p>如果我们不能把不同路由对应的组件分割成不同的代码块,然后当路由被访问的时候才加载对应组件,这样就更加高效了</p>
            <p>路由懒加载做的事情 - 路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块,只有在这个路由被访问到的时候,才加载对应的组件</p>
            <p>在ES6中,可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;const Home = () => import('../components/Home.vue')</p>
            <h3>路由的嵌套</h3>
            <p>比如在home页面中,希望通过/home/news和/home/message访问一些内容</p>
            <p>一个路径映射一个组件,访问这两个路径也会分别渲染两个组件</p>
            <h3>传递参数的方式</h3>
            <ul>
                <h3>params的类型</h3>
                <li>
                    <p>配置路由格式:/router/:id</p>
                </li>
                <li>
                    <p>传递的方式:在path后面跟上对应的值</p>
                </li>
                <li>
                    <p>传递后形成的路径:/router/123,/router/abc</p>
                </li>
            </ul>
            <ul>
                <h3>query的类型</h3>
                <li>
                    <p>
                        配置路由格式:/router,也就是普通配置
                    </p>
                </li>
                <li>
                    <p>
                        传递的方式:对象中使用query的key作为传递方式
                    </p>
                </li>
                <li>
                    <p>
                        传递后形成的路径:/router?id=123./router?id=abc
                    </p>
                </li>
            </ul>
        </li>
        <hr>
        <h3>$route和$router的区别</h3>
        <p>所有的组件都继承自Vue的原型</p>
        <p>$router为VueRouter实例,想要导航到不同URL,则使用$router.push方法</p>
        <p>$route为当前router跳转对象,里面可以获取name,path,query,params等</p>
        <h3>导航守卫</h3>
        <p>网页标题是通过&lt;title&gt;来显示,但是SPA只有一个固定的HTML,切换不同的页面时,标题并不会改变</p>
        <p>但是我们可以通过javascript来修改&lt;title&gt;的内容.window.document.title = '新的标题'</p>
        <p>那么在Vue项目中,在哪里修改?什么时候修改比较合适呢</p>
        <p>我们比较容易想到的修改标题的位置是每一个路由对应的组件.vue文件中</p>
        <p>通过mounted声明周期函数,执行对应的代码进行修改即可</p>
        <p>但是当页面比较多时,这种方式不容易维护(因为需要再多个页面执行类似的代码)</p>
        <ul>
            <p>更好的方式 - 我们可以利用beforeEach来完成标题的修改</p>
            <li>
                <p>
                    首先,我们可以在钩子当中定义一些标题,可以利用meta来定义
                </p>
            </li>
            <li>
                <p>
                    其次,利用导航收尾,修改我们的标题
                </p>
            </li>
        </ul>
        <ul>
            <p>导航钩子的三个参数解析</p>
            <li>
                to : 即将要进入的目标的路有对象
            </li>
            <li>
                from : 当前导航即将要离开的路由对象
            </li>
            <li>
                next : 调用该方法后,才能进入下一个钩子
            </li>
        </ul>
        <hr>
        <h3>keep-alive与vue-router</h3>
        <ul>
            <li>
                keep-alive是Vue内置的一个组件,可以被包含在组件保留状态,或避免重新渲染
                <ul>
                    <li>
                        include - 字符串或正则表达,只有匹配的组件会被缓存
                    </li>
                    <li>
                        exclude - 字符串或正则表达式,任何匹配的组件都不会被缓存
                    </li>
                </ul>
            </li>
            <li>
                router-view也是一个组件,如果直接被包在keep-alive里面,所有路径匹配到的视图组件都会被缓存
            </li>
            <li>
                一但使用了keep-alive之后,就可以使用activated和deactivated两个判断当前组件是否会激活的函数
            </li>
        </ul>
        <hr>
        <h3>TabBar demo 实现思路</h3>
        <ol>
            <li>
                <p>如果在下方有一个单独的TabBar组件,你如何封装</p>
                <ul>
                    <li>
                        自定义TabBar组件,在APP中使用
                    </li>
                    <li>
                        让TabBar出于底部,并且设置相关的样式
                    </li>
                </ul>
            </li>
            <li>
                <p>TabBar中显示的内容由外界决定</p>
                <ul>
                    <li>
                        定义插槽
                    </li>
                    <li>
                        flex布局评分TabBar
                    </li>
                </ul>
            </li>
            <li>
                <p>自定义TabBarItem,可以传入 图片和文字</p>
                <ul>
                    <li>
                        定义TabBarItem,并且定义两个插槽:图片.文字
                    </li>
                    <li>
                        给两个插槽外层包装div,用于设置样式
                    </li>
                    <li>
                        填充插槽,实现底部TabBar的效果
                    </li>
                </ul>
            </li>
        </ol>
        <li>
            <h1>Promise</h1>
            <ul>
                <p>ES6中一个非常重要和好用的特性就是Promise</p>
                <li>
                    <ul>
                        <li>
                            但是除此接触到Promise会一脸懵逼,这TM是个什么东西
                        </li>
                        <li>
                            看看官方或者一些文章对它的介绍和用法,也是一头雾水
                        </li>
                    </ul>
                </li>
                <li>
                    <p>Promise到底是做什么的呢</p>
                    <ul>
                        <li>Promise是异步编程的一种解决方案</li>
                    </ul>
                </li>
                <li>
                    <p>那什么时候我们会来处理异步事件呢</p>
                    <ul>
                        <li>
                            一种很常见的场景应该就是网络请求了
                        </li>
                        <li>
                            我们封装一个网络请求的函数,因为不能立即拿到结果,所以不能像简单的3+4=7一样将结果烦返回
                        </li>
                        <li>
                            所以旺旺我们会传入另一个函数,在数据请求成功时,将数据通过传入的函数回调出去
                        </li>
                        <li>
                            如果只是一个简单的网络请求,那么这种方案不会给我们带来很大的麻烦
                        </li>
                    </ul>
                </li>
                <li>
                    <p>但是,当网络请求非常复杂时,就会出现回调地狱</p>
                    <ul>
                        <li>可以举例说明</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <h1>Vuex</h1>
            <ul>
                <p>Vuex是一个专门为Vue.js应用程序开发的状态管理模式</p>
                <li>
                    它采用集中式存储管理引用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化
                </li>
                <li>
                    Vuex也集成到Vue的官方调试工具 devtools extension,提供了诸如零配置的 time-travel调试,状态快照导入导出等高级调试功能
                </li>
            </ul>
            <ul>
                <p>状态管理是什么</p>
                <li>
                    状态管理模式,集中式存储管理这些词听起来就非常高大上,让人捉摸不透
                </li>
                <li>
                    其实,你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面
                </li>
                <li>
                    然后,将这个对象放在顶层的Vue实例中,让其组件可以使用
                </li>
                <li>
                    那么,多个组件是不是可以共享这个对象变量属性了呢
                </li>
            </ul>
            <ul>
                <p>等等,如果是这样的话,为什么官方还要专门出一个插件Vuex呢?难道我们不能自己封装一个对象来管理么?</p>
                <li>
                    当然可以,只是我们要先想想Vuejs给我们带来的最大遍历是什么?没错,是响应式
                </li>
                <li>
                    如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢?当然也可以,只是自己封装可能稍微麻烦一些
                </li>
                <li>
                    不用怀疑,Vuex就是为了提供这样一个多组件间共享状态的插件,用它就对了
                </li>
            </ul>
            <h3>
                有什么状态是需要再多个组件之间共享呢?
            </h3>
            <ul>
                <li>
                    如果开发大型项目,一定会遇到多个状态,在多个界面间的共享问题
                </li>
                <li>
                    比如用户的登录状态,用户名称,头像,地理信息等
                </li>
                <li>
                    比如商品的收藏,购物车中的物品等等
                </li>
                <li>
                    这些状态信息,我们都可以放在统一的地方,对它进行保存和管理,而且他们还是响应式的
                </li>
            </ul>
            <ul>
                <li>
                    <p>Vue已经帮我们做好了单个界面的状态管理,但是如果是多个界面呢?</p>
                    <ul>

                        <li>
                            多个视图都以来同一个状态(一个状态改了,多个界面都需要进行更新)
                        </li>
                        <li>
                            不同接麦你的Actions都想修改同一个状态(Home.vue需要更改,Profile.vue也需要修改这个状态)
                        </li>
                    </ul>
                </li>
                <li>
                    <p>也就是说对于某些状态来说只属于我们某一个视图,但是也有一这些状态,属于多个视图共同想要维护的状态</p>
                    <ul>
                        <li>
                            状态1/状态2/状态3放在自己的房间里面,自己管理自己用,没问题
                        </li>
                        <li>
                            但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理
                        </li>
                        <li>
                            Vuex就是为我们提供这个大管家的工具
                        </li>
                    </ul>
                </li>
                <li>
                    <p>全局单列模式</p>
                    <ul>
                        <li>
                            我们现在要做的就是将共享的状态抽取出来,交给我们的大管家,统一进行管理
                        </li>
                        <li>
                            之后,你们每个视图,都按照规定好的规定,进行访问和修改等操作
                        </li>
                        <li>
                            这就是Vuex背后的基本思想
                        </li>
                    </ul>
                </li>
            </ul>
            <ul>
                <h2>Vuex有几个比较核心的概念</h2>
                <li>
                    <h2>State</h2>
                    <p>状态信息的管理</p>
                    <ul>
                        <li>
                            <p>Vuex提出使用单一状态树,什么是单一状态树呢</p>
                            <ul>
                                <li>英文名称是Single Source of Truth,也可以翻译成单一数据源</li>
                            </ul>
                        </li>
                        <li>
                            <p>但是,他有什么用呢,可以举一个生活中的例子</p>
                            <ul>
                                <li>
                                    用一个生活中的简单例子做类比
                                </li>
                                <li>
                                    我们知道,在国内我们有很多的信息需要被记录,比如上学时的个人档案,工作之后的社保记录,公积金记录,结婚后的婚姻信息,以及其他的相关的户口,医疗,文凭,房产记录等(还有很多信息)
                                </li>
                                <li>
                                    这些信息被分散在很多地方进行管理,有一天你需要办某个业务时(比如入户某个城市),你会发现你需要到各个对应的工作地点去打印盖章各种资料信息,最后到一个地方提交证明你的信息是无误的
                                </li>
                                <li>
                                    这种保存信息的方案,不仅仅低效,而且不方便管理,以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护,当然国家目前已经在完善我们这个系统了)
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>这个和我们在应用开发中比较类似</p>
                            <ul>
                                <li>
                                    如果你的状态信息是保存到多个Store对象中,那么之后的管理和维护等等都会变得特别困难
                                </li>
                                <li>
                                    所以Vuex也使用了单一状态树来管理应用层级的全部状态
                                </li>
                                <li>
                                    单一状态树能够让我们最直接的方式找到某个状态的片段,而且在之后的维护和调试过程中,也可以非常方便的管理和维护
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <h2>Getters</h2>
                    <p>
                        Geters可以定义一些全局组件都可以使用的方法,通常是对state里面的存储数据做过滤操作,比如等级制度,1代表初级,2代表中级,3代表高级.在state中存储level值为1,2或者3,想在页面中获取对应的登记就需要进行转换,那么这个时候就需要用到getters
                    </p>
                </li>
                <li>
                    <h2>Mutation</h2>
                    <p>Vuex的store状态的更新唯一方式:提交Mutation</p>
                    <ul>
                        <p>Mutation主要包括两部分</p>
                        <li>
                            字符串的事件类型(type)
                        </li>
                        <li>
                            一个回调函数(handler),该回调函数的第一个参数就是state
                        </li>
                    </ul>
                    <ul>
                        <p>在通过mutation更新数据的时候,后可能我们希望携带一些额外的参数</p>
                        <li>参数被称为是mutation的载荷(Payload)</li>
                    </ul>
                    <ul>
                        <p>但是如果参数不是一个呢</p>
                        <li>
                            比如我们有很多参数需要传递
                        </li>
                        <li>
                            这时候,我们通常会以对象的形式传递,也就是Payload是一个对象
                        </li>
                        <li>
                            这个时候可以再从对象中取出相关的信息
                        </li>
                    </ul>
                    <ul>
                        <li>上面通过commit来进行提交是一种普通的方式</li>
                        <li>Vue还提供了另一钟封装,它是一个包含type属性的对象</li>
                        <li>Mutation中的处理方式是将整个commit的对象作为payload使用,所以代码没有改变,依然传递,但是在index.js中接收时,需要用paload.count来获取count的值,因为此时传递过去的是一个对象</li>
                    </ul>
                    <ul>
                        <p>Mutation的响应规则</p>
                        <li>Vuex的store中的state是响应式的,当state中的数据发生改变时,Vue组件会自动更新</li>
                        <li>
                            <p>这就是我们必须遵循一些Vuex对应的规则</p>
                            <ul>
                                <li>
                                    提前在store中初始化好所需的属性
                                </li>
                                <li>
                                    当给state中的对象添加新属性时,使用下面的方式
                                    <ol>
                                        <li>
                                            使用Vue.set(obj,'newProp',123)
                                        </li>
                                        <li>
                                            用新对象给旧对象重新赋值
                                        </li>
                                    </ol>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <ul>
                        <p>考虑以下问题</p>
                        <li>
                            在mutation中,我们定义了很多事件类型(也就是其中的方法名称)
                        </li>
                        <li>
                            当我们的项目增大时,Vuex管理的状态越来越多,需要更新状态的情况越来越多,那么意味着Mutation中的方法越来越多
                        </li>
                        <li>
                            方法过多,使用者需要花费大量的精力去记住这些方法,甚至是多个文件间来回切换,查看方法名称,甚至如果不是复制的时候,可能还会出现写错的情况
                        </li>
                    </ul>
                </li>
                <li>
                    <h2>Action</h2>
                    <ul>
                        <p>我们强调,不要在Mutation中进行异步操作</p>
                        <li>
                            但是某些情况,我们确实希望在Vuex中进行一些异步操作,比如网络请求,必然是一步的,这个时候怎么处理呢
                        </li>
                        <li>
                            Action类似于Mutation,但是是用来代替Mutation进行异步操作的
                        </li>
                    </ul>
                </li>
                <li>
                    <h2>Module</h2>
                    <ul>
                        <p>Module是模块的意思,为什么在Vuex中我们要使用模块呢</p>
                        <li>
                            <ul>
                                <li>
                                    Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理
                                </li>
                                <li>
                                    当应用编的非常复杂时,store对象就有可能变得相当臃肿
                                </li>
                                <li>
                                    为了解决这个问题,Vuex允许我们将store分割成模块(Module),而每个模块拥有自己的,State,Mutation,Action,Getters等
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <h1>Axios</h1>
            <ul>
                <li>
                    <p>Vue中发送网络请求有非常多的方式,那么,在开发中,如何选择呢</p>
                    <ul>
                        <li>
                            <p>选择一:传统的Ajax是基于XMLHttpRequest(XHR)</p>
                            <ol>
                                <p>为什么不使用它呢?</p>
                                <li>
                                    配置和调用方式等非常混乱
                                </li>
                                <li>
                                    编码起来看起来就非常蛋疼
                                </li>
                                <li>    
                                    所以真是开发中很少直接使用,而是使用jQuery-Ajax
                                </li>
                            </ol>
                        </li>
                        <li>
                            <p>选择二:使用jQuery-Ajax 相对于传统的Ajax非常好用</p>
                            <ol>
                                <p>为什么不选择它呢</p>
                                <li>
                                    明确一点:在Vue的整个开发中都是不需要使用jQuery了
                                </li>
                                <li>    
                                    那么,就意味着为了方便我们进行一个网络请求,特意引用一个jQuery,你觉得合理么
                                </li>
                                <li>
                                    jQuery 1W+行<br>
                                    Vue的代码才 1W+行
                                </li>
                                <li>
                                    完全没有必要为了用网络请求就引用在这个重量级的框架
                                </li>   
                            </ol>
                        </li>
                        <li>
                            <p>选择三:官方在Vue1.x的时候,推出了Vue-resource</p>
                            <ul>
                                <li>Vue-resource的体积相对于jQuery小很多</li>
                                <li>另外Vue-resource是官方推出的</li>
                            </ul>
                            <ol>
                                <p>为什么不选择呢</p>
                                <li>在Vue2.0推出后,Vue作者尤雨溪在Github的Issues中就说明了去掉vue-resource,并且以后也不会再更新</li>
                                <li>那么意味着以后vue-reource不再支持新的版本,也不回再继续更新和维护</li>
                                <li>对以后的项目开发和维护都存在很大的隐患</li>
                            </ol>
                        </li>
                        <li>
                            <p>选择四:在说明白不再更新和维护vue-resource的同时,作者还推荐了一个框架:axios </p>
                            <ol>
                                <li>
                                    axios有非常多的优点,并且用起来也非常方便
                                </li>
                            </ol>
                        </li>
                    </ul>
                </li>
                <li>
                    <p>在前端开发中,我们一种常见的网络请求方式就是JSPNP</p>
                    <ol>
                        <li>使用JSONP最主要的原因往往是为了解决跨域访问的问题</li>
                    </ol>
                </li>
                <li>
                    <p>JSONP的原理是什么呢</p>
                    <ol>
                        <li>
                            JSONP的核心在于通过&lt;script&gt;标签的src来帮助我们请求数据
                        </li>
                        <li>
                            原因是我们在项目部署在domain1.com服务器上时,是不能直接访问domain2.com服务器上的资料的
                        </li>
                        <li>
                            这个时候,我们利用&lt;script&gt;标签的src帮助我们去服务器请求到数据,将数据当做一个javascript的函数来执行,并且执行的过程中传入我们需要的json
                        </li>
                        <li>
                            所以,封装jsonp的核心就在于我们监听window上的jsonp进行回调时的名称
                        </li>
                    </ol>
                </li>
            </ul>
            <h4>为什么推荐AXIOS</h4>
            <ul>
                <p>功能特点</p>
                <li>
                    在浏览器中发送XMLHttpRequests请求
                </li>
                <li>
                    在node.js中发送http请求
                </li>
                <li>
                    支持Promise API
                </li>
                <li>
                    拦截请求和响应
                </li>
                <li>
                    转换请求和响应数据
                </li>
            </ul>
            
            <ul>
                <h4>支持多种请求方式</h4>
                <li>
                    axios(config)
                </li>
                <li>
                    axios.request(config)
                </li>
                <li>
                    axios.get(url[,config])
                </li>
                <li>
                    axios.delte(url[,config])
                </li>
                <li>
                    axios.head(url[,config])
                </li>
                <li>
                    axios.post(url[,data[,config]])
                </li>
                <li>
                    axios.put(url[,data[,config]])
                </li>
            </ul>
        </li>
    </ul>

</body>

</html>